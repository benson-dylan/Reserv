{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"C:/Users/vintd/Documents/GitHub/Reserv/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport cx from 'clsx';\nvar EMPTY_CLASS_NAMES = {};\nfunction mergeClassNames(objects) {\n  var merged = {};\n  objects.forEach(function (obj) {\n    Object.entries(obj).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n      if (merged[key]) {\n        merged[key] = cx(merged[key], value);\n      } else {\n        merged[key] = value;\n      }\n    });\n  });\n  return merged;\n}\nfunction resolveClassNames(_ref3) {\n  var theme = _ref3.theme,\n    classNames = _ref3.classNames,\n    props = _ref3.props,\n    stylesCtx = _ref3.stylesCtx;\n  var arrayClassNames = Array.isArray(classNames) ? classNames : [classNames];\n  var resolvedClassNames = arrayClassNames.map(function (item) {\n    return typeof item === \"function\" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES;\n  });\n  return mergeClassNames(resolvedClassNames);\n}\nexport { resolveClassNames };","map":{"version":3,"names":["EMPTY_CLASS_NAMES","mergeClassNames","objects","merged","forEach","obj","Object","entries","_ref","_ref2","_slicedToArray","key","value","cx","resolveClassNames","_ref3","theme","classNames","props","stylesCtx","arrayClassNames","Array","isArray","resolvedClassNames","map","item"],"sources":["C:\\Users\\vintd\\Documents\\GitHub\\Reserv\\frontend\\node_modules\\@mantine\\core\\src\\core\\styles-api\\use-styles\\get-class-name\\resolve-class-names\\resolve-class-names.ts"],"sourcesContent":["import cx from 'clsx';\nimport { MantineTheme } from '../../../../MantineProvider';\nimport type { _ClassNames } from '../get-class-name';\n\nexport interface ResolveClassNamesInput {\n  theme: MantineTheme;\n  classNames: _ClassNames;\n  props: Record<string, any>;\n  stylesCtx: Record<string, any> | undefined;\n}\n\nconst EMPTY_CLASS_NAMES: Partial<Record<string, string>> = {};\n\nfunction mergeClassNames(objects: Partial<Record<string, string>>[]) {\n  const merged: Partial<Record<string, string>> = {};\n\n  objects.forEach((obj) => {\n    Object.entries(obj).forEach(([key, value]) => {\n      if (merged[key]) {\n        merged[key] = cx(merged[key], value);\n      } else {\n        merged[key] = value;\n      }\n    });\n  });\n\n  return merged;\n}\n\nexport function resolveClassNames({ theme, classNames, props, stylesCtx }: ResolveClassNamesInput) {\n  const arrayClassNames = Array.isArray(classNames) ? classNames : [classNames];\n  const resolvedClassNames = arrayClassNames.map((item) =>\n    typeof item === 'function' ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES\n  );\n\n  return mergeClassNames(resolvedClassNames);\n}\n"],"mappings":";;;;AACA,IAAMA,iBAAiB,GAAG,EAAE;AAC5B,SAASC,eAAeA,CAACC,OAAO,EAAE;EAChC,IAAMC,MAAM,GAAG,EAAE;EACjBD,OAAO,CAACE,OAAO,CAAC,UAACC,GAAG,EAAK;IACvBC,MAAM,CAACC,OAAO,CAACF,GAAG,CAAC,CAACD,OAAO,CAAC,UAAAI,IAAA,EAAkB;MAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAF,IAAA;QAAhBG,GAAG,GAAAF,KAAA;QAAEG,KAAK,GAAAH,KAAA;MACtC,IAAIN,MAAM,CAACQ,GAAG,CAAC,EAAE;QACfR,MAAM,CAACQ,GAAG,CAAC,GAAGE,EAAE,CAACV,MAAM,CAACQ,GAAG,CAAC,EAAEC,KAAK,CAAC;MAC5C,CAAO,MAAM;QACLT,MAAM,CAACQ,GAAG,CAAC,GAAGC,KAAK;MAC3B;IACA,CAAK,CAAC;EACN,CAAG,CAAC;EACF,OAAOT,MAAM;AACf;AACO,SAASW,iBAAiBA,CAAAC,KAAA,EAA0C;EAAA,IAAvCC,KAAK,GAAAD,KAAA,CAALC,KAAK;IAAEC,UAAU,GAAAF,KAAA,CAAVE,UAAU;IAAEC,KAAK,GAAAH,KAAA,CAALG,KAAK;IAAEC,SAAS,GAAAJ,KAAA,CAATI,SAAS;EACrE,IAAMC,eAAe,GAAGC,KAAK,CAACC,OAAO,CAACL,UAAU,CAAC,GAAGA,UAAU,GAAG,CAACA,UAAU,CAAC;EAC7E,IAAMM,kBAAkB,GAAGH,eAAe,CAACI,GAAG,CAC5C,UAACC,IAAI;IAAA,OAAK,OAAOA,IAAI,KAAK,UAAU,GAAGA,IAAI,CAACT,KAAK,EAAEE,KAAK,EAAEC,SAAS,CAAC,GAAGM,IAAI,IAAIzB,iBAAiB;EAAA,CACpG,CAAG;EACD,OAAOC,eAAe,CAACsB,kBAAkB,CAAC;AAC5C"},"metadata":{},"sourceType":"module","externalDependencies":[]}